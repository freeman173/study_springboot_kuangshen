一、spring的介绍

    一个轻量级、控制反转（ioc）、面向切面编程（aop）的框架！


二、spring的组成以及拓展

组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：
    
    核心容器：核心容器提供了spring框架的基本功能。核心容器的主要组件是beanfactory（工厂模式的实现）。
beanfactory使用控制反转（ioc）将应用程序的配置、依赖性规范与实际的应用程序代码分开。


    Spring AOP：（还不是很懂）
        通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。
    所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 
    的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。


    Spring MVC 框架：
    MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，
MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。




三、ioc

1、ioc理论推导
在ioc01案例中：
    在UserServiceImpl中，在使用了set方法动态注入dao层对象后，程序不再需要去主动创建所需对象。
    程序可以专注于业务的实现（需要的工具类直接由框架提供），这就是ioc的原型


2、ioc本质

ioc（控制反转：获取依赖对象的方式反转了）是一种设计思想，DI(依赖注入)是它的一种实现方式。

ioc是一种通过描述（xml/注解）去获取所需对象的方式；在spring中，实现ioc的方式是ioc容器，实现方法为依赖注入！



3、ioc具体实现

见ioc-02即可。
    

4、依赖注入

    构造器注入：
        
        见代码即可

    set注入；
        见代码即可


5、bean的作用域

singleton：在spring IoC容器仅存在一个Bean实例，bean作用域范围的默认值。
    在单例中，每个Spring IoC容器只有一个实例，无论创建多少个对象，调用多少次getMessafe( )方法获取它，它总是返回同一个实例。

prototype：每次从容器中调用Bean时，都返回一个新的实例。



6、bean的自动装配

    含义：spring在ioc中自动给bean装配属性（自动寻找与属性对应的值或对象,不用我们开发人员去手动配置）

    三种方式：
        在xml文件中实现自动配置；
               autowire="byName"：在ioc中自动查找，跟自己对象set方法名所对应的beanid：“setCat”对应beanid "cat";
                                  保证所有的beanid唯一。

               autowire="byType"：在ioc中自动查找，跟自己对象属性相同类型的bean;
                                  保证所有bean的class唯一。

        java中配置；


        隐式自动装配（重点）；
    

    使用注解自动装配：
        
        @Autowired:通过 autowire="byType"的方式实现。

        @Qualifier:跟@Autowired配合使用；@Autowired默认是根据类型进行注入的，因此如果有多个类型一样的Bean候选者，
            则需要使用 @Qualifier 限定其中一个候选者。

        @Resource:先通过 autowire="byName"的方式实现，如果不行在通过 autowire="byType"的方式实现。



7、在spring中使用注解开发(具体实现见Ioc-03)

    几个常用注解：
        @Component：
            dao：@Repository
            service：@Service
            controller：@Controller  
        注：这四个注解功能一样！

    
    小结：
        xml与注解的对比：
            xml更加万能，维护方便，但是创建繁琐；
            注解创建方便，但维护复杂。

        xml用来管理bean，注解用来完成属性的注入，这样配合会比较好！



8、在spring中使用javaconfig来代替配置文件（具体实现见Ioc-04）

    由于Spring会把几乎所有的业务类都以Bean的形式配置在XML文件中，造成了大量的XML文件。
 JavaConfig就是使用注释来描述Bean配置的组件。




9、aop

9.1、代理模式（见ioc-05）

    一、静态代理：
    
            角色分析：
                抽象业务角色：租房
                真实角色：房东，被代理角色
                代理角色：中介，代理房东，做一些附属操作
                客户：房客。
    
            
            代理模式的好处：
                使得真实角色的操作更加纯粹，公关业务交给代理来做，方便后续业务的扩展！
                
            不足：
                一个角色产生一个代理，有些麻烦！
            
            
    
    
        二、动态代理
            
            一个动态代理类可以代理多个类（只要实现了同一个接口即可）。

            需要了解两个类：
                Proxy：实现代理功能
                InvocationHandler：调用处理程序
    
            具体实现见代码！


注：动态代理的原理还是一知半解，后面需要时再回来深入了解！


9.2、aop（具体实现见ioc-06）

 1、实例：
 我们以数据库的操作为例来说明：
    1、获取连接对象；
    2、执行SQL(核心业务代码)；
    3、如果有异常,回滚事务,无异常则提交事务；
    4、关闭连接。

    上述的几个部署，“2”是核心业务代码，其他都是非核心业务代码，但是我们又必须写 。
而面向切面编程就是为了解决这样的问题，将这些非核心业务代码进行抽离，这样开发者只需要关注“核心业务代码”即可。


2、相关概念：


    （2）横切关注点：与核心业务逻辑无关但需要我们关注的部分：日志、安全、事务…………。
    
    （3）切面：横切关注点被模块化的特殊对象，一个具体类。
    
    （4）通知：切面必须完成的工作，切面类中的一个方法。

    （5）目标：被通知的对象。
    
    （6）代理： 一个类被AOP织入增强后，就产生了一个代理类。
    
     （7）连接点（Joinpoint) 程序执行的某个特定位置，如某个方法调用前，调用后，方法抛出异常后，这些代码中的特定点称为连接点。
简单来说，就是在哪加入你的逻辑增强。

     （8）切点：在连接点切入。


3、aop的实现方式

    继承使用spring-aop相关接口来实现：
        稍微复杂，但功能更强（可以使用反射等技术操作目标对象）
    
    自定义接口来实现：
        简单；但是功能相对弱一些（相比于第一种）

    注解实现：
        将“自定义接口来实现”改为了注解实现





10、在spring中的事务管理

这部分不想学，后面再做了解！！













