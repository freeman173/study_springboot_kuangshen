package Java_Basic;


/*


    Java语言是一个纯的面向对象程序设计语言。在Java中，一切皆为对象。
源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。

    主方法是JVM的启动入口：所有的Java 程序由public static void main(String []args)方法开始执行；
JVM在启动时就是按照上述方法的签名(必须有public、static修饰，返回值为void，且方法的参数为字符串数组)来查找方法的入口地址，若找到就执行，找不到就会报错。
    static表明main()方法是一个静态方法，即方法中的代码时存储在静态区的，只要类被加载后，就可以使用该方法而不需要通过实例化对象来访问，
可以直接通过 类名.main() 直接访问；
    　同一个Java文件是否可以有多个main()方法，虽然每个类都可以定义main方法，但是只有与文件名相同的用public修饰的类中的main方法
才能作为整个程序的入口方法。
      main方法必须声明为静态的，这样JVM才可以调用main方法而无需实例化它的类。
      main方法必须public。你不能定义main方法为private和protected，也不能不用访问修饰符。这是为了能让JVM访问main方法。




在java中的面向对象：
    java只支持单继承；
    子类拥有父类非 private 的属性、方法；
    继承可以使用 extends（继承对象） 和 implements（继承接口，可以继承多个） 这两个关键字来实现继承；
    super 与 this 关键字：
        super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。
        this关键字：指向自己的引用。
    使用 final 关键字声明类，就是把类定义定义为最终类，不能被继承，或者用于修饰方法，该方法不能被子类重写。

    子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过
super 关键字调用父类的构造器并配以适当的参数列表。如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动
调用父类的无参构造器。


    重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。
    重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。



    多态是同一个行为具有多个不同表现形式或形态的能力。


    抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。
由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。
    如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。
Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。





Java 集合框架主要包括两种类型的容器：
    一种是集合（Collection），存储一个元素集合。
    另一种是图（Map），存储键/值对映射。

    集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：

        接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象

        实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。

        算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。


        还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了Iterator 接口或 ListIterator接口。
    迭代器，使你能够通过循环来得到或删除集合的元素。


    Collections中定義了一些框架數據結構的常用方法，必要時可以拿來用！


    Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，子类可以使用 Object 的所有方法。
我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 Object，成为 Object 的子类。


    泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。
根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。
    所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔）。。一个泛型参数，也被称为一个类型变量。




    Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、
有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，
也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。整个过程都是 Java 虚拟机（JVM）独立的，
也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。






 */





import Java_Basic.OBJECT.*;
import Java_Basic.OBJECT.Dog;

public class Test {

    public static void main(String[] args) {
//        System.out.println("Hello World");
//        int a=10;
//        String b="dkdfk";
//        System.out.println(args[0]+args[1]);
//        HelloWorld a = new HelloWorld();
//        a.Speak();
//        Dog dog=new Dog("刘琪");
//        dog.setDogage(24);
//        System.out.println(dog.getDogage()+ dog.getDogname());

//          Data_LeiXing A=new Data_LeiXing();
//          A.data_leixing();
//            Loop A=new Loop();
//            A.loop();
//            Ctrl+Shift+Enter：智能提示
//            XuanZe A=new XuanZe();
//            A.xuanze();
//        YiChang A = new YiChang();
//          A.yichang();

//            Jc A=new Jc();
//            A.eattest();
//
//            A.test();
//            A.test(5);
//        每个动物都有工作：猫有猫的工作；动物有动物的工作。
//            Animal A=new Cat();
//            A.work();
//            Animal B=new Dog();
//            B.work();
//          System.out.println("ok");
//        Bird A=new Bird();
//        A.eat();
//        A.travel();




    }
}






