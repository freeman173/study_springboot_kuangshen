一、设计模式
    设计模式是一套经过反复使用的代码设计经验，目的是为了重用代码、让代码更容易被他人理解、保证代码可靠性。

    设计模式的基本要素：
        给问题一个解决方案、效果如歌

    
    设计模式分为23类（GoF23）：
        创建型模式：共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
        结构型模式：共7种：适配器模式、装饰器模式、代理模式、桥接模式、外观模式、组合模式、享元模式。
        行为型模式：共11种：策略模式、模板方法模式、观察者模式、责任链模式、访问者模式、中介者模式、
    迭代器模式、命令模式、状态模式、备忘录模式、解释器模式。
        
    
    oop七大原则：
        开闭原则：扩展开放、修改关闭
        里氏替换原则：任何基类可以出现的地方，子类一定可以出现。
        依赖倒置原则：针对接口编程。
        单一职责原则：功能尽可能单一提高其内聚性。
        接口隔离原则：每个类都有其专用接口
        迪米特原则（最少知道原则）：只跟熟人说话。
        合成复用原则：尽量使用组合/聚合的方式，而不是使用继承。


创建型模式：

    二、工厂模式
    
    1、核心本质：
        实例化对象不用new，用工厂方法代替。
    
    2、三种模式
    
        简单工厂：不遵循开闭原则，但使用最多
        工厂方法：为每个类增加一个工厂。
        抽象工厂：围绕一个超级工厂创建其他工厂。具体见代码！
    
        补充知识点：如果使用接口的引用去访问它的实现类的方法，那么一定只能访问实现类中接口所定义的那个方法，
    其他的变量和方法是无法访问的。
    
    
    
    三、建造者模式
    
    定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
    主要作用：使得用户在不必清楚对象的具体内部细节情况下就可以直接创建复杂对象。
    
    具体实现见案例！
    
    
    
    
    四、原型模式
    
    原型模式也是用于对象的创建，通过将一个对象作为原型，对其进行复制克隆，产生一个与源对象类似的新对象。
    
    在 Java 中，原型模式的核心是就是原型类 Prototype，Prototype 类需要具备以下两个条件：
        实现 Cloneable 接口：
        重写 Object 类中的 clone() 方法，用于返回对象的拷贝；
    
    
    Object 类中的 clone() 方法默认是浅拷贝，如果想要深拷贝对象，则需要在 clone() 方法中自定义自己的复制逻辑。
        浅复制：将一个对象复制后，基本数据类型的变量会重新创建，而引用类型指向的还是原对象所指向的内存地址。
        深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。
    
    
    详情见代码，简单了解一下就行！



结构型模式
    一、适配器模式
        适配器模式主要用于将一个类或者接口转化成客户端希望的格式，使得原本不兼容的类可以在一起工作，将目标类和适配者类解耦。（两个不同国家语言的人相互交流不行，需要一个中间翻译）

        适配器模式的主要实现有三种：类的适配器模式、对象的适配器模式、接口的适配器模式:
            有需要再来更进一步了解！

    
    二、桥接模式
        桥接模式将系统的抽象部分与实现部分分离解耦，使他们可以独立的变化。
    抽象部分拥有实现部分的接口对象，从而能够通过这个接口对象来调用具体实现部分的功能。
    也就是说，桥接模式中的桥接是一个单方向的关系，只能够抽象部分去使用实现部分的对象，而不能反过来。

        比如：Java 中，我们使用 JDBC 连接数据库时，在各个数据库之间进行切换，基本不需要动太多的代码，原因就是使用了桥接模式，
    JDBC 提供统一接口，每种类型的数据库提供各自的实现，然后由桥接类创建一个连接数据库的驱动，使用某一个数据库的时候只需要切换一下就行。



代理模式：
    
    一、静态代理：
        
        角色分析：
            抽象业务角色：租房
            真实角色：房东，被代理角色
            代理角色：中介，代理房东，做一些附属操作
            客户：房客。

        
        代理模式的好处：
            使得真实角色的操作更加纯粹，公关业务交给代理来做，方便后续业务的扩展！
            
        不足：
            一个角色产生一个代理，有些麻烦！
        
        


    二、动态代理
        
        一个动态代理类可以代理多个类（只要实现了同一个接口即可）。
        
        需要了解两个类：
            Proxy：实现代理功能
            InvocationHandler：调用处理程序

        具体实现见代码！




二、java反射技术

    在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；
这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

    要想解剖一个类(使用的就是Class类中的方法),必须先要获取到该类的字节码文件对象；
Class 类的实例表示正在运行的 Java 应用程序中的类和接口；Class 对象是在加载类时由 
Java 虚拟机以及通过调用类加载器中的defineClass 方法自动构造的。

    将类的各个组成部分封装为其他对象，这就是反射机制！
    


注：具体实现见代码
        



三、java注解

1、什么是注解？
    
作用： 可以对程序做出解释；可以被其他程序读取。Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，
    起到说明、配置的功能。
格式：@dddd(value="")
使用位置：
    可以放在package、class、method、field，可以通过反射机制与注解相结合使用。


2、内置注解

@Override

@Deprecated:不推荐但可以用

@SuppressWarning：镇压警告


    
3、元注解：注解的注解（负责解释其他注解）

@Target：标记这个注解应该是哪种 Java 成员。
@Retention：标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。
@Documented：标记这些注解是否包含在用户文档中。
@Inherited：子类可以继承父类中的该注解



4、自定义注解
使用@interface来自定义注解即可。


5、反射获取注解信息

见代码
